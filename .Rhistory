ytest = testdf[,varname]
}
return(rbind(train=Err(pre_train,y),
test=Err(pre_test,ytest)))
}
movingLM = function( #using moving data to predict
df,
oldday = 7, # how many days of data to be used
#newday = 1, # NOTICE: not used for now!!!
testdate = ymd("2016-8-1")
){
alldat = unique(df$date[df$date>=testdate])
prediction = rep(NA, length(alldat)*24*4)
i=1
for(dat in alldat){
testdf = df[df$date==dat,]
traindf = df[df$date %in% ((dat-oldday):(dat-1)),]
fit = lm(outy ~ weekdays + hour + minute, data=traindf)
prediction[i:(i-1+24*4)] = predict(fit, testdf)
i = i+24*4
}
return(Err(prediction, df[df$date>=testdate,"outy"]))
}
testmovingLM=function(MCdf,range){
tb = c()
for(i in range){
tb = rbind(tb,movingLM(MCdf, oldday=i))
message(i)
}
return(cbind(day=range,tb))
}
MakeData = function(df,
varname, # the var to be predicted
#timevars = c("weekdays","hour","minute"), # the time var names
hist_day = c(1,7) #, # use which days before to be the input data
#future_day = 1  # how many steps to be predicted
){
n = nrow(df)
n_hist = length(hist_day)
df$day = as.numeric(day(df$time))
df$weekdays = wday(df$time)
df$hour = as.numeric(hour(df$time))
df$minute = as.numeric(minute(df$time))
X = array(dim=c(n, n_hist * 96+ 4*96))
# X: each row: history data + time vars
Y = array(dim=c(n, 96))
for(i in 1:n){
ind1 = i:(i-1+96)
if(sum(ind1>n | ind1<=0)>0){next}
Y[i,] = unlist(df[ind1,varname])
X[i,(1:96)+96*0] = df$day[ind1]
X[i,(1:96)+96*1] = df$weekdays[ind1]
X[i,(1:96)+96*2] = df$hour[ind1]
X[i,(1:96)+96*3] = df$minute[ind1]
for(j in 1:n_hist){
ind2 = (i-96*hist_day[j]):(i-96*hist_day[j]+96-1)
if(sum(ind2>n | ind2<=0)>0){next}
X[i,(1:96)+96*(3+j)] = unlist(df[ind2,varname])
}
if(i%%1000==0){message(i/n)}
}
ind = ((rowSums(is.na(X)) + rowSums(is.na(Y))) ==0)
return(list(X=X[ind,],Y=Y[ind,]))
}
cutdata = function(data, use, train_rate=0.7){
n = nrow(data$X)
if(use=="train"){
ind = 1:round(n*train_rate)
return(list(X=data$X[ind,],Y=data$Y[ind,]))
}
if(use=="test"){
ind = (round(n*train_rate)+1):n
return(list(X=data$X[ind,],Y=data$Y[ind,]))
}
message('Error: use can only be "train" or "test"!!!')
}
findpars = function(x){
mins = apply(x,2,min)
maxs = apply(x,2,max)
sclas = maxs-mins
return(list(mins=mins,scales=sclas))
}
scale01 = function(x,pars){ # for scaling to 0-1
mins = pars$mins
scales = pars$scales
for(i in 1:ncol(x)){
x[,i] = (x[,i]-mins[i]) / scales[i]
}
return(x)
}
Rscale01 = function(x,pars){ # for reversing centralization
mins = pars$mins
scales = pars$scales
for(i in 1:ncol(x)){
x[,i] = x[,i]*scales[i]+mins[i]
}
return(x)
}
trainModel = function(data, func, ...){
parsX = findpars(data$X)
parsY = findpars(data$Y)
X = scale01(data$X, parsX)
Y = scale01(data$Y, parsY)
model = func(X,Y, ...)
return(list(model=model, parsX=parsX, parsY=parsY))
}
predictModel = function(model, data){
X = scale01(data$X, model$parsX)
Yp= predict(model$model, X)
return(Rscale01(Yp,model$parsY))
}
LMpredict = function( #using moving data to predict
df,testdate,
oldday = 22 # how many days of data to be used
){
testdf = df[df$date==testdate,]
traindf = df[df$date %in% ((testdate-oldday):(testdate-1)),]
fit = lm(outy ~ weekdays + hour + minute, data=traindf)
return(predict(fit, testdf))
}
evaluate = function(Batrate){
# 检查长度
#if(length(Batrate)!=nx){message("Length Error!");return(NA)}
# 计算Bat,sell
Bat = (iny - outy) * Batrate
Sell = iny - outy - Bat
Batreal = Bat # true electricity in the battery
Batreal[Bat>0] = Bat[Bat>0] * batrateio # 充电效率
# 电池容量约束惩罚
batnow = cumsum(Batreal) + 0.8*batmax
pun = punish * (sum((batnow - batmax)[batnow > batmax]) +
-sum(batnow[batnow < 0]) +
if(0.8*batmax>batnow[nx]){(0.8*batmax-batnow[nx])*nx}else{0}+ #（最后电量保持80%以上)
sum((Bat - bat15max)[Bat > bat15max]) + # 电池充放电速率惩罚
sum((bat15min - Bat)[Bat < bat15min]))
return( # cost =
-sum(ifelse(Sell>0, sellp, buyp) * Sell) +
batdepre * sum(abs(Bat)) +
pun
)
}
calc_profit= function(real_iny, real_outy, batnow){
batnowreal = 0.8 * batmax
Batreal = rep(NA, nx)
for(i in (1:nx)){
IO = real_iny[i] - real_outy[i]
target = batnow[i] - batnowreal
if(IO * target <=0) {Batreal[i]=0}else{
if(IO>0){
Batreal[i] = min(target/batrateio, IO, (batmax - batnowreal)/batrateio, bat15max)
}else{
Batreal[i] = max(target, IO, (-batnowreal), bat15min)
}
}
batnowreal = batnowreal + ifelse(Batreal[i]>0,Batreal[i]*batrateio, Batreal[i])
}
Sellreal = real_iny - real_outy - Batreal
if(sum(Batreal * Sellreal<0)>0){stop("Error2!")}
#plot the bat
plot(batnow,type='l',ylim=c(0,batmax))
lines(cumsum(ifelse(Batreal>0,Batreal*batrateio,Batreal))+0.8*batmax,col='red')
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal) +
-batdepre * sum(abs(Batreal))+
subsidy_all +
ifelse(sum(Batreal)<0, sum(Batreal)*mean(buyp), sum(Batreal)*mean(sellp))
)
}
calc_profit_all_bat = function(real_iny, real_outy){
batnowreal = 0.8 * batmax
Batreal = rep(NA, nx)
for(i in (1:nx)){
IO = real_iny[i] - real_outy[i]
if(IO>0){
Batreal[i] = min(IO, (batmax - batnowreal)/batrateio, bat15max)
}else{
Batreal[i] = max(IO, (-batnowreal), bat15min)
}
batnowreal = batnowreal + ifelse(Batreal[i]>0,Batreal[i]*batrateio, Batreal[i])
}
Sellreal = real_iny - real_outy - Batreal
if(sum(Batreal * Sellreal<0)>0){stop("Error2!")}
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal) +
-batdepre * sum(abs(Batreal))+
subsidy_all +
ifelse(sum(Batreal)<0, sum(Batreal)*mean(buyp), sum(Batreal)*mean(sellp))
)
}
calc_profit_no_bat = function(real_iny, real_outy){
Sellreal = real_iny - real_outy
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal)+
subsidy_all
)
}
PSOsolve = function(iny,outy, real_iny, real_outy){
PSOresult = list(par=rep(1,nx))
subsidy_all <<- sum(real_iny) * subsidy
time0 = now()
cost=c(evaluate(rep(0.5,nx)))
i = 1 # the n.row of cost
while(i<2 || cost[i-1]-cost[i]>no_improvement){
PSOresult = psoptim(PSOresult$par,evaluate,lower = rep(0,nx),upper=rep(1,nx),
control = control)
i=i+1
cost[i] = evaluate(PSOresult$par)
}
# calculate the real profit:
Bat = (iny - outy) * PSOresult$par
Batreal = Bat
Batreal[Bat>0] = Bat[Bat>0] * batrateio # 充电效率
batnow = cumsum(Batreal) + 0.8*batmax
if(sum((batnow>batmax) + (batnow<0)) >0 ){stop("Error1!")}
return(list(time = as.duration(now()-time0),
Bat = Bat,
Batreal = Batreal,
realProfit = calc_profit(real_iny,real_outy,batnow)))
}
MCforOpt = function(df = MCdf, tb = MCresult, method = "prediction"){
ntimes = nrow(MCresult)
for(i in 1:ntimes){
real_iny <<- df$iny[df$date==tb$indate[i]]
real_outy <<- df$outy[df$date==tb$outdate[i]]
iny <<- real_iny
if(method=="real"){outy <<- real_outy}else{outy <<- LMpredict(df, tb$outdate[i])}
#plot the prediction
plot(real_outy,type='l', main='Prediction Effectiveness')
lines(outy, col='red')
nx <<- length(iny)
#print(ggplot(NULL,aes(x=1:96,y=iny))+geom_line(color=2)+geom_line(aes(x=1:96,y=outy),color=3))
PSOresult= PSOsolve(iny, outy, real_iny, real_outy)
tb$profit[i] = PSOresult$realProfit
tb$time[i] = PSOresult$time
tb$solution[i] = list(PSOresult$Bat)
#print(ggplot(NULL,aes(x=1:96,y=cumsum(tb$solution[[i]])))+geom_line(color=2))
# all bat:
tb$all_bat[i] = calc_profit_all_bat(real_iny, real_outy)
# no bat:
tb$no_bat[i] = calc_profit_no_bat(real_iny, real_outy)
message("#####################################")
message(i/ntimes)
message("#####################################")
}
rm(real_iny,real_outy,iny,outy,subsidy_all,nx,envir = .GlobalEnv)
return(tb)
}
MCtimes = 20 # how many times the MC will run?
daylist = unique(MCdf$date) # the list that you can select from
daylist = daylist[50:length(daylist)] # atlist 50 days for training
subsidy = 0.42 * (1-0.17) * (1-0.25) # 补贴，减去增值税和所得税
buy = function(hour){
# 上海市电网夏季销售电价表（单一制分时电价用户）工商业及其他用电 http://www.sgcc.com.cn/dlfw/djzc/
return(ifelse(hour>=6 & hour<22, 1.044, 0.513))
}
sell = 0.85-subsidy # minus subsidy, because it always exists
buyp = buy(hour(MCdf$time[1:96]))
sellp = rep(sell, 96)
hours = sort(rep(0:23,4))
buyp = buy(hours)
buyp
sellp = rep(sell, 96)
batmax = 10000 # 电池容量(kwh)
punish = 1e10 # 过量惩罚系数
bat15min = -0.2 * batmax /4 # 过量惩罚系数
bat15max = 0.2 * batmax /4 # 每15分钟最大充电/放电值: 每小时充放电容量不能超过其最大容量的 20%
batdepre = 0.1# 电池折旧成本／（kW·h）
batrateio = 0.8 # 电池充放电效率
no_improvement = 2 # how much profit increase is condidered to be no improvement
control = list(maxit = 3000, trace=T, REPORT=500) # the control for psoptim()
df = read_csv('out.csv')
df$iny
iny = df$iny
outy = df$outyp
real_iny = df$iny
real_outy = df$outytrue
df = read.csv('out.csv')
iny = df$iny
outy = df$outyp
real_iny = df$iny
real_outy = df$outytrue
df = read.csv('out.csv')
iny = df$iny
outy = df$outyp
real_iny = df$iny
real_outy = df$outytrue
PSOsolve(iny,outy,real_iny,real_outy)
nx=length(iny)
PSOsolve(iny,outy,real_iny,real_outy)
temp = PSOsolve(iny,outy,real_iny,real_outy)
temp$time
calc_profit_all_bat(real_iny, real_outy)
calc_profit_no_bat(real_iny, real_outy)
data.frame(temp)
data.frame(time = temp$time, profit= temp$realProfit)
temp = PSOsolve(iny,real_outy,real_iny,real_outy)
output = data.frame(time = c(result1$time,result1$time),
profit= c(result1$realProfit,result1$realProfit))
result1 = PSOsolve(iny,outy,real_iny,real_outy)
result2 = PSOsolve(iny,real_outy,real_iny,real_outy)
output = data.frame(time = c(result1$time,result1$time),
profit= c(result1$realProfit,result1$realProfit))
output = data.frame(time = c(result1$time,result1$time),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
output = data.frame(time = c(result1$time,result1$time,0,0),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
View(output)
output = data.frame(time = c(result1$time,result2$time,0,0),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
View(output)
outy
real_outy
write_csv(output, 'Routput.csv')
df = read.csv('out.csv')
iny = df$iny
outy = df$outyp
real_iny = df$iny
real_outy = df$outytrue
nx=length(iny)
result1 = PSOsolve(iny,outy,real_iny,real_outy)
outy = real_outy
result2 = PSOsolve(iny,outy,real_iny,real_outy)
output = data.frame(time = c(result1$time,result2$time,0,0),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
write_csv(output, 'Routput.csv')
output = data.frame(time = as.numeric(c(result1$time,result2$time,0,0)),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
View(output)
dur <- duration(hours = 10, minutes = 6)
as.numeric(dur, "hours")
as.numeric(dur, "minutes")
dur <- duration(hours = 10, minutes = 6)
as.numeric(dur, "hours")
as.numeric(dur, "s")
library(pso)
library(pso)
evaluate = function(Batrate){
# 检查长度
#if(length(Batrate)!=nx){message("Length Error!");return(NA)}
# 计算Bat,sell
Bat = (iny - outy) * Batrate
Sell = iny - outy - Bat
Batreal = Bat # true electricity in the battery
Batreal[Bat>0] = Bat[Bat>0] * batrateio # 充电效率
# 电池容量约束惩罚
batnow = cumsum(Batreal) + 0.8*batmax
pun = punish * (sum((batnow - batmax)[batnow > batmax]) +
-sum(batnow[batnow < 0]) +
if(0.8*batmax>batnow[nx]){(0.8*batmax-batnow[nx])*nx}else{0}+ #（最后电量保持80%以上)
sum((Bat - bat15max)[Bat > bat15max]) + # 电池充放电速率惩罚
sum((bat15min - Bat)[Bat < bat15min]))
return( # cost =
-sum(ifelse(Sell>0, sellp, buyp) * Sell) +
batdepre * sum(abs(Bat)) +
pun
)
}
calc_profit= function(real_iny, real_outy, batnow){
batnowreal = 0.8 * batmax
Batreal = rep(NA, nx)
for(i in (1:nx)){
IO = real_iny[i] - real_outy[i]
target = batnow[i] - batnowreal
if(IO * target <=0) {Batreal[i]=0}else{
if(IO>0){
Batreal[i] = min(target/batrateio, IO, (batmax - batnowreal)/batrateio, bat15max)
}else{
Batreal[i] = max(target, IO, (-batnowreal), bat15min)
}
}
batnowreal = batnowreal + ifelse(Batreal[i]>0,Batreal[i]*batrateio, Batreal[i])
}
Sellreal = real_iny - real_outy - Batreal
if(sum(Batreal * Sellreal<0)>0){stop("Error2!")}
#plot the bat
#plot(batnow,type='l',ylim=c(0,batmax))
#lines(cumsum(ifelse(Batreal>0,Batreal*batrateio,Batreal))+0.8*batmax,col='red')
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal) +
-batdepre * sum(abs(Batreal))+
subsidy_all +
ifelse(sum(Batreal)<0, sum(Batreal)*mean(buyp), sum(Batreal)*mean(sellp))
)
}
calc_profit_all_bat = function(real_iny, real_outy){
batnowreal = 0.8 * batmax
Batreal = rep(NA, nx)
for(i in (1:nx)){
IO = real_iny[i] - real_outy[i]
if(IO>0){
Batreal[i] = min(IO, (batmax - batnowreal)/batrateio, bat15max)
}else{
Batreal[i] = max(IO, (-batnowreal), bat15min)
}
batnowreal = batnowreal + ifelse(Batreal[i]>0,Batreal[i]*batrateio, Batreal[i])
}
Sellreal = real_iny - real_outy - Batreal
if(sum(Batreal * Sellreal<0)>0){stop("Error2!")}
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal) +
-batdepre * sum(abs(Batreal))+
subsidy_all +
ifelse(sum(Batreal)<0, sum(Batreal)*mean(buyp), sum(Batreal)*mean(sellp))
)
}
calc_profit_no_bat = function(real_iny, real_outy){
Sellreal = real_iny - real_outy
return(
sum(ifelse(Sellreal>0, sellp, buyp) * Sellreal)+
subsidy_all
)
}
PSOsolve = function(iny,outy, real_iny, real_outy){
PSOresult = list(par=rep(1,nx))
subsidy_all <<- sum(real_iny) * subsidy
time0 = now()
cost=c(evaluate(rep(0.5,nx)))
i = 1 # the n.row of cost
while(i<2 || cost[i-1]-cost[i]>no_improvement){
PSOresult = psoptim(PSOresult$par,evaluate,lower = rep(0,nx),upper=rep(1,nx),
control = control)
i=i+1
cost[i] = evaluate(PSOresult$par)
}
# calculate the real profit:
Bat = (iny - outy) * PSOresult$par
Batreal = Bat
Batreal[Bat>0] = Bat[Bat>0] * batrateio # 充电效率
batnow = cumsum(Batreal) + 0.8*batmax
if(sum((batnow>batmax) + (batnow<0)) >0 ){stop("Error1!")}
return(list(time = as.duration(now()-time0),
Bat = Bat,
Batreal = Batreal,
realProfit = calc_profit(real_iny,real_outy,batnow)))
}
MCforOpt = function(df = MCdf, tb = MCresult, method = "prediction"){
ntimes = nrow(MCresult)
for(i in 1:ntimes){
real_iny <<- df$iny[df$date==tb$indate[i]]
real_outy <<- df$outy[df$date==tb$outdate[i]]
iny <<- real_iny
if(method=="real"){outy <<- real_outy}else{outy <<- LMpredict(df, tb$outdate[i])}
#plot the prediction
plot(real_outy,type='l', main='Prediction Effectiveness')
lines(outy, col='red')
nx <<- length(iny)
#print(ggplot(NULL,aes(x=1:96,y=iny))+geom_line(color=2)+geom_line(aes(x=1:96,y=outy),color=3))
PSOresult= PSOsolve(iny, outy, real_iny, real_outy)
tb$profit[i] = PSOresult$realProfit
tb$time[i] = PSOresult$time
tb$solution[i] = list(PSOresult$Bat)
#print(ggplot(NULL,aes(x=1:96,y=cumsum(tb$solution[[i]])))+geom_line(color=2))
# all bat:
tb$all_bat[i] = calc_profit_all_bat(real_iny, real_outy)
# no bat:
tb$no_bat[i] = calc_profit_no_bat(real_iny, real_outy)
message("#####################################")
message(i/ntimes)
message("#####################################")
}
rm(real_iny,real_outy,iny,outy,subsidy_all,nx,envir = .GlobalEnv)
return(tb)
}
subsidy = 0.42 * (1-0.17) * (1-0.25) # 补贴，减去增值税和所得税
buy = function(hour){
# 上海市电网夏季销售电价表（单一制分时电价用户）工商业及其他用电 http://www.sgcc.com.cn/dlfw/djzc/
return(ifelse(hour>=6 & hour<22, 1.044, 0.513))
}
sell = 0.85-subsidy # minus subsidy, because it always exists
hours = sort(rep(0:23,4))
buyp = buy(hours)
sellp = rep(sell, 96)
batmax = 10000 # 电池容量(kwh)
punish = 1e10 # 过量惩罚系数
bat15min = -0.2 * batmax /4 # 过量惩罚系数
bat15max = 0.2 * batmax /4 # 每15分钟最大充电/放电值: 每小时充放电容量不能超过其最大容量的 20%
batdepre = 0.1# 电池折旧成本／（kW·h）
batrateio = 0.8 # 电池充放电效率
no_improvement = 2 # how much profit increase is condidered to be no improvement
control = list(maxit = 3000, trace=T, REPORT=500) # the control for psoptim()
df = read.csv('out.csv')
iny = df$iny
outy = df$outyp
real_iny = df$iny
real_outy = df$outytrue
nx=length(iny)
result1 = PSOsolve(iny,outy,real_iny,real_outy)
outy = real_outy
library(lubridate)
result1 = PSOsolve(iny,outy,real_iny,real_outy)
outy = real_outy
result2 = PSOsolve(iny,outy,real_iny,real_outy)
output = data.frame(time = as.numeric(c(result1$time,result2$time,0,0),'s'),
profit= c(result1$realProfit,result1$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
View(output)
output = data.frame(time = as.numeric(c(result1$time,result2$time,0,0),'s'),
profit= c(result1$realProfit,result2$realProfit,
calc_profit_all_bat(real_iny, real_outy),
calc_profit_no_bat(real_iny, real_outy)))
write.csv(output, 'Routput.csv')
